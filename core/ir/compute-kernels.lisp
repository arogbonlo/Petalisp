;;;; Â© 2016-2018 Marco Heisig - licensed under AGPLv3, see the file COPYING     -*- coding: utf-8 -*-

(in-package :petalisp-ir)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Conversion of Subtree Fragments to Kernels
;;;
;;; The goal is to convert a given subtree of a data flow graph to a list
;;; of kernels.  The subtree is delimited by nodes that have a
;;; corresponding entry in the buffer table.  By choosing the iteration
;;; space of our kernels appropriately, we can eliminate all fusion nodes
;;; in the subtree.
;;;
;;; The algorithm consists of two phases.  In the first phase, we compute a
;;; partitioning of the shape of the root into multiple iteration spaces.
;;; These spaces are chosen such that their union is the shape of the root,
;;; but such that each iteration space selects only a single input of each
;;; encountered fusion node.  In the second phase, each iteration space is
;;; used to create one kernel and its body.  The body of a kernel is an
;;; s-expression describing the interplay of applications, reductions and
;;; references.

;;; An immediate node has no kernels.
(defmethod compute-kernels ((root immediate) (backend backend))
  '())

;;; For all non-immediate strided arrays, we create one kernel per
;;; fusion-free iteration space.
(defmethod compute-kernels ((root strided-array) (backend backend))
  (loop for iteration-space in (compute-iteration-spaces root)
        collect
        (make-simple-kernel
         backend
                            :iteration-space iteration-space
                            :body (compute-simple-kernel-body root iteration-space))))

(defmethod compute-kernels ((root reduction) (backend backend))
  (let ((reduction-stores
          (loop for n below (length (inputs root))
                collect
                (if (= n (value-n root))
                    (cons (gethash root *buffer-table*)
                          (make-identity-transformation (dimension root)))
                    nil)))
        ;; Surprise!  The reduction range of a reduction kernel is not the
        ;; reduction range of the corresponding reduction node.  Instead,
        ;; it is a reduction of the same size, but starting from zero and
        ;; with a step size of one.
        (reduction-range
          (make-range 0 1 (1- (set-size (reduction-range root))))))
    (loop for iteration-space in (compute-iteration-spaces root)
          collect
          (make-reduction-kernel
           backend
           :reduction-range reduction-range
           :iteration-space iteration-space
           :reduction-stores reduction-stores
           :operator (operator root)
           :body
           (compute-reduction-kernel-body
            root
            (enlarge-shape iteration-space reduction-range))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Kernel Iteration Spaces

(defvar *kernel-iteration-spaces*)
(defun compute-iteration-spaces (root)
  (let ((*kernel-iteration-spaces* '()))
    (compute-iteration-spaces-aux
     root
     root
     (shape root)
     (make-identity-transformation (dimension root)))
    ;; The list of iteration spaces generated by COMPUTE-ITERATION-SPACES
    ;; may be empty if there are zero fusion nodes in the subtree.  In this
    ;; case, we return the shape of the root instead.
    (or *kernel-iteration-spaces*
        (list (shape root)))))

;;; Return a boolean indicating whether any of the inputs of NODE, or any
;;; of the inputs thereof, is a fusion node.  Furthermore, whenever NODE is
;;; a fusion node, push a new iteration space for each input that contains
;;; no further fusion nodes.
(defgeneric compute-iteration-spaces-aux
    (root node iteration-space transformation))

(defmethod compute-iteration-spaces-aux :around
    ((root strided-array)
     (node strided-array)
     (iteration-space shape)
     (transformation transformation))
  (if (eq root node)
      (call-next-method)
      (if (nth-value 1 (gethash node *buffer-table*))
          nil
          (call-next-method))))

(defmethod compute-iteration-spaces-aux
    ((root strided-array)
     (fusion fusion)
     (iteration-space shape)
     (transformation transformation))
  ;; Check whether any inputs are free of fusion nodes.  If so, push an
  ;; iteration space.
  (loop for input in (inputs fusion) do
    (let ((subspace (set-intersection iteration-space (shape input))))
      ;; If the input is unreachable, we do nothing.
      (unless (set-emptyp subspace)
        ;; If the input contains fusion nodes, we also do nothing.
        (unless (compute-iteration-spaces-aux root input subspace transformation)
          ;; We have an outer fusion.  This means we have to add a new
          ;; iteration space, which we obtain by projecting the current
          ;; iteration space to the coordinate system of the root.
          (push (transform subspace (invert-transformation transformation))
                *kernel-iteration-spaces*)))))
  t)

(defmethod compute-iteration-spaces-aux
    ((root strided-array)
     (reference reference)
     (iteration-space shape)
     (transformation transformation))
  (compute-iteration-spaces-aux
   root
   (input reference)
   (transform
    (set-intersection iteration-space (shape reference))
    (transformation reference))
   (compose-transformations (transformation reference) transformation)))

(defmethod compute-iteration-spaces-aux
    ((root strided-array)
     (reduction reduction)
     (iteration-space shape)
     (transformation transformation))
  (let* ((range (reduction-range reduction))
         (size (set-size range))
         (iteration-space
           (enlarge-shape
            iteration-space
            (make-range 0 1 (1- size))))
         (transformation
           (enlarge-transformation
            transformation
            (range-step range)
            (range-start range))))
    (loop for input in (inputs reduction)
            thereis
            (compute-iteration-spaces-aux root input iteration-space transformation))))

(defmethod compute-iteration-spaces-aux
    ((root strided-array)
     (application application)
     (iteration-space shape)
     (transformation transformation))
  (loop for input in (inputs application)
          thereis
          (compute-iteration-spaces-aux root input iteration-space transformation)))

(defmethod compute-iteration-spaces-aux
    ((root strided-array)
     (immediate immediate)
     (iteration-space shape)
     (transformation transformation))
  nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Computing the Kernel Body

(defvar *instructions*)

(defvar *kernel-root*)

(defun emit-instruction (operator loads stores)
  (push (make-instruction *backend* :operator operator :loads loads :stores stores)
        *instructions*))

;;; Emit a instruction that writes the value of NODE to some location and
;;; return that location.
(defgeneric assign (node iteration-space transformation))

(defun compute-simple-kernel-body (root iteration-space)
  (let ((*kernel-root* root)
        (*instructions* '())
        (transformation
          (make-identity-transformation (dimension iteration-space))))
    (emit-instruction
     'values
     (list
      (assign root iteration-space transformation))
     (list
      (cons (gethash root *buffer-table*) transformation)))
    (nreverse *instructions*)))

(defun compute-reduction-kernel-body (root iteration-space)
  (let ((*backend* *backend*)
        (*kernel-root* root)
        (*instructions* '()))
    (let ((transformation
            (make-identity-transformation (dimension iteration-space))))
      (loop for input in (inputs root)
            for index from 0 do
              (emit-instruction
               'values
               (list
                (assign input iteration-space transformation))
               (list
                (reduction-value-symbol index)))))
    (nreverse *instructions*)))

;; Check whether we are dealing with a leaf, i.e., a node that has a
;; corresponding entry in the buffer table and is not the root node.  If
;; so, return a reference to that buffer.
(defmethod assign :around ((node strided-array)
                           (iteration-space shape)
                           (transformation transformation))
  ;; The root node has an entry in the buffer table, yet we do not want to
  ;; treat it as a leaf node.
  (if (eq node *kernel-root*)
      (call-next-method)
      (multiple-value-bind (buffer buffer-p)
          (gethash node *buffer-table*)
        (if buffer-p
            (cons buffer transformation)
            (call-next-method)))))

(defmethod assign ((application application)
                   (iteration-space shape)
                   (transformation transformation))
  (let ((value-n (value-n application))
        (result (gensym)))
    (emit-instruction
     (operator application)
     (loop for input in (inputs application)
           collect
           (assign input iteration-space transformation))
     (nreverse
      (cons result (make-list value-n))))
    result))

(defmethod assign ((reference reference)
                   (iteration-space shape)
                   (transformation transformation))
  (assign
   (input reference)
   (transform
    (set-intersection iteration-space (shape reference))
    (transformation reference))
   (compose-transformations (transformation reference) transformation)))

(defmethod assign ((fusion fusion)
                   (iteration-space shape)
                   (transformation transformation))
  (let ((input (find iteration-space (inputs fusion)
                     :key #'shape
                     :test #'set-intersectionp)))
    (assign
     input
     (set-intersection iteration-space (shape input))
     transformation)))

(defmethod assign ((strided-array strided-array)
                   (iteration-space shape)
                   (transformation transformation))
  (error "No way to process ~S" strided-array))
