% -*- TeX-master: "petalisp.tex" -*-
\section{The Design of Petalisp}
\label{sec:design}

If the design goal of Petalisp had to be summarized in one sentence, it
would be:

\begin{quotation}
  Every Petalisp program can be executed efficiently on a parallel
  computer
\end{quotation}

\noindent A consequence of this goal is that other language qualities, such
as expressiveness are sacrificed where necessary. The design process
thereby turns into a search for the minimal set of features that are
sufficient to denote typical parallel algorithms. The result of this
minimization problem is a language with only a single data structure and
four primitive operators, which are described hereafter.

\subsection{Strided Arrays}

Computation is hardly meaningful without structured data. In classical
Lisps, this role is filled by the \texttt{cons} function, from which all
other data structures can be derived. However, this approach produces data
structures that are far too heterogeneous for any automatic
parallelization. Instead Petalisp uses a data structure that has far more
data regularity: strided arrays.

Strided arrays are an extension of classical arrays, where the valid
elements in each dimension are denoted by three integers: The smallest
admissible index, the step size and the highest admissible index. More
precisely, strided arrays can be defined as:

\begin{define}[range]
  A range with the lower bound $x_L$, the step size $s$ and the upper bound
  $x_U$, with $x_L, s, u_U \in \Z$, is the set of integers
  $$\{\, x \in \Z \;|\; x_{L} \le x \le x_{U} \;\wedge\; (\exists k \in \Z)\,[ x = x_{L} + k s]\,\}$$
\end{define}

\begin{define}[strided array]
  A strided array in $n$ dimensions is a function from elements of the
  cartesian product of $n$ ranges to a set of Common Lisp objects.
\end{define}

Because strided arrays are so important, they deserve their own
notation. The shape of a strided array is denoted by an S-expression,
starting with the Greek letter $\sigma$ (for \textbf{s}pace or
\textbf{s}hape), followed by lists of integers denoting the lower bound,
step size and upper bound of each range, as in the following examples:

\begin{figure}[h]
\begin{tabular}{ll}
  \texttt{($\sigma$)}                         & \hspace{-1em} the zero-dimensional space \\
  \texttt{($\sigma$ (0 1 8) (0 1 8))}         & \hspace{-1em} index space of a $9 \times 9$ array \\
  \texttt{($\sigma$ (10 2 98))}               & \hspace{-1em} all even two-digit numbers \\
  \texttt{($\sigma$ (1 2 3) (1 2 3) (1 2 3))} & \hspace{-1em} corners of a $3 \times 3 \times 3$ cube \\
\end{tabular}
\caption{A notation for strided arrays.}
\label{fig:sigma-examples}
\end{figure}

Strided arrays have several advantages over classical arrays, as used
e.g. in the APL programming language \cite{APL}: The lowest and highest
index can be chosen arbitrarily, including from the set of negative
integers \footnote{Coincidentally avoiding any debate over a canonical
  lowest array index.}. This flexibility is later used to define
translations of arrays and subsequently to define an unambiguous way to
stack multiple strided arrays next to each other.

The additional step size parameter fills also an important role. Many
parallel algorithms have some nearest neighbor data dependencies. To
parallelize them nonetheless, the domain must be partitioned into multiple
independent sets. This process is called coloring. A simple example of such
a coloring strategy is a chessboard, which ensures that the direct
neighbors of any white field are black, and vice versa. All elements with
the same color can be grouped into a small number of strided arrays. In the
case of the chessboard, two strided arrays are sufficient to describe all
tiles of the same color.

\subsection{Core Operations}

Before the four core operations of Petalisp are discussed, it is
instructive to discuss those features that are not present in
Petalisp. Petalisp lacks any form of control flow --- no conditionals, no
function calls, no jumps and no mechanism for exception handling. Even
more, there is no mechanism for destructive assignment. As a result, a
Petalisp program is nothing more than a pure data flow graph.

The most prominent Petalisp operator is the distributed
\emph{application}. It describes embarrassingly parallel problems, where a
single function is applied to every element of one or more strided arrays,
much like the Lisp function \texttt{map}. A secondary source of parallelism
is introduced by the distributed \emph{reduction} operator, which is
similar to the Lisp function \texttt{reduce}, but where the order of
reduction is unspecified. In the case of multidimensional arrays, only the
last dimension is reduced.

\begin{define}[application]
  Let $f$ be a referentially transparent\footnote{A function is
    referentially transparent if it has negligible side effects and same
    arguments always yield the same value.} Common Lisp function that
  accepts $n$ arguments, and let $a_{1}, \ldots, a_{n}$ be strided arrays
  with index space $\Omega$. Then the application of $f$ to
  $a_{1}, \ldots, a_{n}$ is a strided array that maps each index $k$ of
  $\Omega$ to $f( a_{1}(k), \ldots, a_{n}(k) )$.
\end{define}

\begin{define}[reduction]
  Let $f$ be a referentially transparent Common Lisp function that accepts
  two arguments, and let $a$ be strided array of dimension $n$, i.e. a
  mapping from each element of the cartesian product of the ranges
  $R_{1}, \ldots, R_{n}$ to some values. Then the reduction of $a$ by $f$
  is a Petalisp data structure of dimension $n-1$ that maps each element
  $k$ of $R_{1} \,\times\, \ldots \, \times \, R_{n-1}$ to the combination of the
  elements $\{ a(i) \,|\, i \in k \,\times\, \Omega_{n} \}$ by $f$ in some
  arbitrary order.
\end{define}

Parallel application and reduction are the only two operators that actually
evaluate Common Lisp functions to compute new values.

\begin{define}[fusion]
  Let $a_{1}, \ldots, a_{n}$ be strided arrays, each mapping from a set of
  indices $\Omega_{k}$ to a set of values.  Furthermore, let the sets
  $\Omega_{1}, \ldots, \Omega_{n}$ be pairwise disjoint. Then the fusion of
  $a_{1},\ldots, a_{n}$ is a strided array that maps each index
  $i \in \bigcup_{k=1}^{n} \Omega_{k}$ to the value of $i$ of the unique data
  structure $a_{k}$ whose domain contains $x$.
\end{define}

% reference

\subsection{Transformations}