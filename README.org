#+TITLE: Petalisp

Petalisp is an attempt to generate high performance code for parallel
computers from a pure data flow specification. It is not a full blown programming language, but rather a carefully crafted extension of Common Lisp that allows for extreme optimization and parallelization.


** Keeping it small and simple
Petalisp aims to be small and simple. It is an universal truth that (given similar indentation) one thousand lines of code are easier to read and maintain than one million lines of code. But please do NOT obtain this brevity by using short names and few comments and line breaks. Write short code by using abstraction and generic methods.

If you are curious, the following snippet tells you the current size of Petalisp in non-whitespace source lines of code:

#+BEGIN_SRC sh
find . -path './.git' -prune -o -print | egrep '\.asd|\.lisp' | xargs cat | sed '/^\s*$/d' | wc -l
#+END_SRC

** Showcases
Petalisp is still under development, so the following examples may still change slightly. Nevertheless they give a good glimpse on what programming with Petalisp will be like.

Example 1: transposing a matrix
#+BEGIN_SRC lisp
(defun transpose (A)
  (reshape A (m n) (n m)))
#+END_SRC

Example 2: a simple matrix multiplication
#+BEGIN_SRC lisp
(defun matrix-multiplication (A B)
  (β+ (α* (reshape A (m n) (m 1 n))
          (reshape B (n k) (1 k n)))))
#+END_SRC

Example 3: the numerical Jacobi scheme in two dimensions for a simple discretization
#+BEGIN_SRC lisp
(defun take (array x y)
  (let ((center
          (select array
           ((+ start step) step (- end step))
           ((+ start step) step (- end step)))))
    (select (reshape array (a b) ((+ a x) (+ b y)))
            center)))

(defun jacobi-2d (x iterations)
  (if (zerop iterations) x
      (jacobi-2d
       (substitute
        (α * 0.25
           (α +
              (take x  1  0)
              (take x -1  0)
              (take x  0  1)
              (take x  0 -1)))
        x)
       (- iterations 1))))
#+END_SRC

Example 4: A full Petalisp program to multiply a matrix from a file with a
lisp constant and store it again.
#+BEGIN_SRC lisp
(defun matmult (A B)
  (β + (α * (reshape A (m n) (m 1 n))
            (reshape B (n k) (1 k n)))))

(defvar C (matmult
           (hdf5-file "A.h5" "matrix")
           #2((1 2) (3 4))))

(wait (store C (ascii-file "C.ascii")))
#+END_SRC
